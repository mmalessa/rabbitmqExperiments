# https://github.com/php-amqplib/RabbitMqBundle/blob/master/README.md
# ./bin/console config:dump-reference old_sound_rabbit_mq

old_sound_rabbit_mq:

    connections:
        default:
            host:     '%env(RABBITMQ_HOST)%'
            port:     '%env(RABBITMQ_PORT)%'
            user:     '%env(RABBITMQ_USER)%'
            password: '%env(RABBITMQ_PASSWORD)%'
            vhost:    '%env(RABBITMQ_VHOST)%'

            lazy:     true
            # Lazy Queues - queues that move their contents to disk as early as practically possible

            connection_timeout: 1000
            # Time in milliseconds (an integer) to wait while establishing a TCP connection to the server before giving up.

            heartbeat: 60
            # Heartbeat timeout value in seconds (an integer) to negotiate with the server.

            read_write_timeout: 600
            # In seconds (must be at least = heartbeat x 2)

            keepalive: false
            # Use TCP Keepalives


        ssl_connection:
            host:     '%env(RABBITMQ_HOST)%'
            port:     '%env(RABBITMQ_PORT_SSL)%'
            user:     '%env(RABBITMQ_USER)%'
            password: '%env(RABBITMQ_PASSWORD)%'
            vhost:    '%env(RABBITMQ_VHOST)%'

            lazy:     true
            connection_timeout: 1000
            read_write_timeout: 3600
            keepalive: false
            heartbeat: 60

            ssl_context:
                cacert:   '/home/projects/rabbitmqExperiments/config/ssl/ca/cacert.pem'
                local_cert:   '/home/projects/rabbitmqExperiments/config/ssl/client/cert.pem'
                local_pk:     '/home/projects/rabbitmqExperiments/config/ssl/client/key.pem'
                verify_peer: false
                verify_peer_name: false
                allow_self_signed: true
                ciphers: 'TLSv1.2'

#    bindings:
#        - {connection: default, exchange: foo, destination: bar, routing_key: 'baz.*', arguments: null, nowait: false}
#        - {connection: default, exchange: foo1, destination: foo, routing_key: 'baz.*', destination_is_exchange: true, arguments: null, nowait: false}


    producers:
        # use 'old_sound_rabbit_mq.my_task_producer' service to send data.
        my_task:
            connection:       default
            exchange_options: { name: 'main_events', type: topic }

    consumers:
        all_logs:
            connection:       default
            exchange_options: { name: 'main_events', type: topic }
            qos_options:     { prefetch_size: 0, prefetch_count: 1, global: false }
            queue_options:
                name: 'all_logs'
                durable: true
                auto_delete: false
                arguments:
                    x-dead-letter-exchange: ['S', 'main_events']
#                    x-dead-letter-exchange: ['S', 'main_events_dead']
                    x-dead-letter-routing-key: ['S', 'test.task_job_done']
#                    x-dead-letter-routing-key: ['S', 'test.task_job_done.rejected']
                    x-max-priority: ['I', 3]
                routing_keys:
                    - '#'
            callback:         App\Consumer\AllLogsConsumer


# QUEUE ARGUMENTS
#
# x-message-ttl[I]
#   determines for how long a message published to a queue can live
#   before it is discarded by the server (in milliseconds)
#
# x-expires [I]
#   where the queue itself will expire after a certain period of time
#   if no messages have been accessed (in milliseconds)
#
# x-max-length [I]
#   for defining how many messges the queue is allowed to hold;
#   messages from the front of the queue will be dead-lettered to make way
#   for new messages when the maximum length is reached
#
# x-max-length-bytes [I]
#   for defining in bytes how large the queue can become;
#   just like the maximum length above, messages from the front of the queue will be dead-lettered first
#
# x-dead-letter-exchange [S]
#   indicates the exchange for routing dead messages out of the queue because they have reached
#   the end of their time-to-live, they exceed the max length (messages or bytes) configured for the queue,
#   or they have been rejected by the queue or nacked (negative acknowledgement) by the consumer
#   due to some issue and are not slated for re-queueing
#
# x-dead-letter-routing-key [S]
#   provides a new routing key context to the dead letter exchange;
#   if no dead letter routing key is set, then the original routing key will be used
#
# x-max-priority [I]
#   allows the queue to prioritize priority messages up to some maximum level you set;
#   messages higher than the maximum for the queue will be re-prioritized down to this maximum level
#
# x-queue-mode [S] ['default'|'lazy']
#   Lazy Queues - queues that move their contents to disk as early as practically possible,
#   and only load them in RAM when requested by consumers, therefore the lazy denomination.

# QOS OPTIONS
#
# prefetch size - prefetch window size in octets, null/0 (?) meaning "no specific limit"
# prefetch count - prefetch window in terms of whole messages
# global - global=null to mean that the QoS settings should apply per-consumer, global=true to mean that the QoS settings should apply per-channel


# If you'd like your consumer to be running up to certain time and then gracefully exit,
# then set the graceful_max_execution.timeout in seconds.
# "Gracefully exit" means, that the consumer will exit either after the currently running task or immediatelly,
# when waiting for new tasks.
# The graceful_max_execution.exit_code specifies what exit code should be returned by the consumer
# when the graceful max execution timeout occurs. Without specifying it, the consumer will exit with status 0.

# TOPIC EXCHANGE
# Messages sent to a topic exchange can't have an arbitrary routing_key - it must be a list of words, delimited by dots.
# The words can be anything, but usually they specify some features connected to the message.
# A few valid routing key examples: "stock.usd.nyse", "nyse.vmw", "quick.orange.rabbit".
# There can be as many words in the routing key as you like, up to the limit of 255 bytes.

# The binding key must also be in the same form.
# The logic behind the topic exchange is similar to a direct one - a message sent with a particular routing key
# will be delivered to all the queues that are bound with a matching binding key.
# However there are two important special cases for binding keys:
#    * (star) can substitute for exactly one word.
#    # (hash) can substitute for zero or more words.
